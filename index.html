<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <script type="text/javascript" src="PlyReader.js"></script> -->
    <script type="text/javascript" src="utils/MV.js"></script>
    <script type="text/javascript" src="utils/helpers.js"></script>
    <script type="text/javascript" src="app.js"></script>
    
    <script id="wgsl" type="x-shader"> 

        const PI: f32 = 3.14159265359;
        const INFINITY: f32 = 1.0e+38;
        
        const TMIN: f32 = 0.0;
        const TMAX: f32 = 1000.0;
        const MAXINTERSECTIONS: u32 = 10;
        const BACKGROUNDCOLOR: vec4f = vec4f(0.1, 0.3, 0.6, 1.0);

        const MAX_LEVEL: u32 = 20;
        const BSP_LEAF: u32 = 3;
        var<private> branch_node: array<vec2u, MAX_LEVEL>; 
        var<private> branch_ray: array<vec2f, MAX_LEVEL>;

        @group(0) @binding(0) var<uniform> uniforms : Uniforms;
        @group(0) @binding(1) var renderTexture: texture_2d<f32>;

        @group(0) @binding(2) var<storage, read> gaussians: array<Gaussian>;
        @group(0) @binding(3) var<storage, read> gaussian_ordering: array<u32>;
        // @group(0) @binding(4) var<storage, read> spherical_harmonics: array<SphericalHarmonics>;
        @group(0) @binding(4) var<storage, read> spherical_harmonics: array<array<vec3<f32>, 16>>;
        @group(0) @binding(5) var<storage, read> inv_covariance_matrices: array<mat3x3<f32>>;

        struct Uniforms {
            eps: f32,
            aspect_ratio: f32,
            gamma: f32,
            frame_number: f32,       // u32 in spirit, not possible in practice
            canvas_width: f32,       // u32 in spirit, not possible in practice
            canvas_height: f32,      // u32 in spirit, not possible in practice
            _padding1: f32,
            camera_const: f32,
            camera_position: vec3f,
            camera_look_point: vec3f,
            camera_up_vector: vec3f,
        };

        struct Gaussian {
            position: vec3f,
            normal: vec3f,
            opacity: f32,
            scale: vec3f,
            rotation: vec4f,
            // material: Material // TODO: THIS is temporary for debugging
        };

        // struct SphericalHarmonics {
        //     coeffs: array<vec3<f32>, 16>
        // };

        struct VSOut {
            @builtin(position) position: vec4f,
            @location(0) coords: vec2f
        };

        struct FSOut {
            @location(0) frame: vec4f, 
            @location(1) accum: vec4f
        };

        struct Ray {
            origin: vec3f,
            direction: vec3f,
            t_min: f32,
            t_max: f32
        };

        struct HitInfo {
            has_hit: bool, 
            dist: f32, 
            position: vec3f, 
            normal: vec3f, 
            material: Material,
            shader: u32,
            entry: vec3f,
            exit: vec3f,
            gaussian: Gaussian
        };

        struct Sphere {
            center: vec3f,
            radius: f32,
            material: Material,
            shader: u32
        };
                
        struct Material {
            color: vec3f,
            emission: vec3f,
            specular: vec3f,
            index_of_refraction: f32,
            specular_reflectance: f32,
            shininess: f32
        };

        struct Plane {
            position: vec3f,
            normal: vec3f,
            material: Material
        };


        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut {
            // Origin in bottom left corner (-1, -1). TODO: Move to js, the same for every vert
            const pos = array<vec2f, 4>(
                vec2f(-1.0, 1.0), 
                vec2f(-1.0, -1.0), 
                vec2f(1.0, 1.0), 
                vec2f(1.0, -1.0)
            );
            
            return VSOut(
                vec4f(pos[VertexIndex], 0.0, 1.0),
                pos[VertexIndex]
            );
        }

        fn get_camera_ray(uv: vec2f) -> Ray {
            // Create camera frame - following the procedure outlined in the book p.86
            let v: vec3f = normalize(uniforms.camera_look_point - uniforms.camera_position);
            let b1: vec3f = normalize(cross(v, uniforms.camera_up_vector));
            let b2: vec3f = cross(b1, v);

            return Ray(
                uniforms.camera_position,
                b1 * uv.x + b2 * uv.y + v * uniforms.camera_const,
                TMIN,
                TMAX
            );
        }

        fn intersect_sphere(ray: ptr<function, Ray>, sphere: Sphere, hit: ptr<function, HitInfo>) -> bool {            
            let o_to_sphere: vec3f = (*ray).origin - sphere.center;

            let a: f32 = dot((*ray).direction, (*ray).direction);
            let b: f32 = 2 * dot(o_to_sphere, (*ray).direction);
            let c: f32 = dot(o_to_sphere, o_to_sphere) - (sphere.radius * sphere.radius);

            let d: f32 = b * b - 4 * a * c;
            
            if (d < 0 ) { return false; }
            
            var t: f32;
            let t1: f32 = (-b - sqrt(d)) / (2.0 * a);
            let t2: f32 = (-b + sqrt(d)) / (2.0 * a);

            if ((*ray).t_min < t1 && t1 < (*ray).t_max) {
                t = t1;
            } else if ((*ray).t_min < t2 && t2 < (*ray).t_max) {
                t = t2;
            } else {
                return false;
            }

            let hit_pos: vec3f = (*ray).origin + (*ray).direction * t;

            // Update the hit info
            (*hit).has_hit = true;
            (*hit).dist = t;
            (*hit).material = sphere.material;
            (*hit).position = hit_pos;
            (*hit).normal = normalize(hit_pos - sphere.center);
            (*hit).shader = sphere.shader;

            // We hit the inside of the sphere, flip normal
            if (0.0 < dot((*ray).direction, (*hit).normal)) {
                (*hit).normal = -(*hit).normal;
            }
            
            return true;
        }
        

        fn quaternion_to_matrix(q: vec4f) -> mat3x3<f32> {
            // See: "Quaternion-derived rotation matrix" https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation 
            let xx = q.x * q.x;
            let yy = q.y * q.y;
            let zz = q.z * q.z;
            let xy = q.x * q.y;
            let xz = q.x * q.z;
            let yz = q.y * q.z;
            let wx = q.w * q.x;
            let wy = q.w * q.y;
            let wz = q.w * q.z;

            return mat3x3<f32>(
                vec3<f32>(1.0 - 2.0 * (yy + zz), 2.0 * (xy - wz), 2.0 * (xz + wy)),
                vec3<f32>(2.0 * (xy + wz), 1.0 - 2.0 * (xx + zz), 2.0 * (yz - wx)),
                vec3<f32>(2.0 * (xz - wy), 2.0 * (yz + wx), 1.0 - 2.0 * (xx + yy))
            );
        }

        fn rotate_vector(v: vec3<f32>, rotation_matrix: mat3x3<f32>) -> vec3<f32> {
            return rotation_matrix * v;
        }

        // Function to calculate normal for a rotated ellipsoid
        // fn calculate_rotated_normal(hit_pos: vec3<f32>, gaussian: Gaussian) -> vec3<f32> {
        //     // Calculate the rotation matrix from the quaternion
        //     let rotation_matrix = quaternion_to_matrix(gaussian.rotation);
            
        //     // Inverse rotation is the transpose of the rotation matrix
        //     let inverse_rotation_matrix = transpose(rotation_matrix);
            
        //     // Transform the hit position into the local space of the ellipsoid
        //     let local_hit_pos = rotate_vector(hit_pos - gaussian.position, inverse_rotation_matrix);
            
        //     // Calculate the normal in local space
        //     let local_normal = normalize(vec3(
        //         local_hit_pos.x / (gaussian.scale.x * gaussian.scale.x),
        //         local_hit_pos.y / (gaussian.scale.y * gaussian.scale.y),
        //         local_hit_pos.z / (gaussian.scale.z * gaussian.scale.z)
        //     ));
            
        //     // Rotate the normal back to world space
        //     let world_normal = rotate_vector(local_normal, rotation_matrix);
            
        //     return world_normal;
        // }
        fn calculate_rotated_normal(hit_pos: vec3<f32>, inv_cov_mat: mat3x3<f32>, gaussian: Gaussian) -> vec3<f32> {
            // Step 1: Transform the hit position to the local space of the ellipsoid
            let localHitPos = inv_cov_mat * (hit_pos - gaussian.position);

            // Step 2: Calculate the normal in local space
            let localNormal = normalize(localHitPos);

            // Step 3: Account for non-uniform scaling
            // For non-uniform scaling, the normal needs to be adjusted by the inverse of the scale factors
            let adjustedNormal = vec3<f32>(
                localNormal.x / gaussian.scale.x,
                localNormal.y / gaussian.scale.y,
                localNormal.z / gaussian.scale.z
            );

            // Rotate the normal back to world space using the quaternion
            let worldNormal = rotate_vector(adjustedNormal, quaternion_to_matrix(gaussian.rotation));

            return normalize(worldNormal);
        }


        fn density_at_point(hit: HitInfo, inv_cov_mat: mat3x3<f32>) -> f32 {
            // Transform the point into the Gaussian's local space
            let localPoint = inv_cov_mat * (hit.position - hit.gaussian.position);

            // Compute the Gaussian density
            let density = exp(-0.5 * dot(localPoint, localPoint));
            return density;
            // return exp(-0.5 * transpose(hit.position))
        }

        fn calculate_alpha(hit: HitInfo) -> f32 {
            let midPoint: vec3f = (hit.entry + hit.exit) * 0.5;
            let distanceFromCenter: f32 = length(midPoint - hit.gaussian.position);
            let sigma: f32 = length(hit.gaussian.scale) / 2.0;  // Assuming uniform scale for simplicity
            let alphaAtMidPoint: f32 = exp(-distanceFromCenter * distanceFromCenter / (2.0 * sigma * sigma));
            
            let pathLength: f32 = length(hit.exit - hit.entry);
            let totalAlpha: f32 = alphaAtMidPoint * pathLength;  // Approximate total alpha
            return totalAlpha;
        }

        // fn calculate_alpha(hit: HitInfo) -> f32 {
        //     let midPoint: vec3f = (hit.entry + hit.exit) * 0.5;
        //     let distanceFromCenter: f32 = length(midPoint - hit.gaussian.position);
        //     let sigma: f32 = length(hit.gaussian.scale) / 2.0;  // Assuming uniform scale for simplicity
        //     let alphaAtMidPoint: f32 = exp(-distanceFromCenter * distanceFromCenter / (2.0 * sigma * sigma));
            
        //     // let pathLength: f32 = length(hit.exit - hit.entry);
        //     // let totalAlpha: f32 = alphaAtMidPoint * pathLength;  // Approximate total alpha
        //     let totalAlpha: f32 = alphaAtMidPoint * hit.gaussian.opacity;
        //     return totalAlpha;
        // } 


        fn calculate_exit_point(inv_cov_mat:mat3x3<f32>, ray: Ray, hit: HitInfo) -> vec3<f32> {
            // Transform the ray into the local space defined by the inverse covariance matrix
            let localRayOrigin = inv_cov_mat * (ray.origin - hit.gaussian.position);
            let localRayDirection = inv_cov_mat * ray.direction;

            // Compute coefficients of the quadratic equation for a unit sphere
            let a = dot(localRayDirection, localRayDirection);
            let b = 2.0 * dot(localRayOrigin, localRayDirection);
            let c = dot(localRayOrigin, localRayOrigin) - 1.0;

            // Solve the quadratic equation
            let discriminant = b * b - 4.0 * a * c;
            if (discriminant < 0.0) {
                return vec3<f32>(0.0, 1.0, 0.0); // No real solution, exit point doesn't exist
            }

            let t0 = (-b - sqrt(discriminant)) / (2.0 * a);
            let t1 = (-b + sqrt(discriminant)) / (2.0 * a);

            // We only want the second intersection, assuming the ray originated outside the sphere
            let t_exit = max(t0, t1);

            // Calculate the exit point in the local space
            let exitPointLocal = localRayOrigin + t_exit * localRayDirection;

            // To transform the local exit point back to world space, we need to perform the inverse of the 
            // transformations that the inverse covariance matrix applied. This involves scaling and then rotating.
            // Since the inverse covariance matrix combined these, we must apply the inverse scaling first and then the inverse rotation.

            // Inverse scale the local exit point
            let scaledExitPoint = exitPointLocal * hit.gaussian.scale;

            // Now we need to rotate this point back to world space. The quaternion must be normalized.
            // Perform the rotation using the quaternion. This will require quaternion-to-matrix conversion
            // or a quaternion rotation function, which you should define based on your environment's capabilities.

            // Assuming you have a function to rotate a point by a quaternion:
            let worldExitPoint = rotate_vector(scaledExitPoint, quaternion_to_matrix(hit.gaussian.rotation));

            // Translate the point by the Gaussian's position to move it back to world space
            return worldExitPoint + hit.gaussian.position;
        }

        // fn calculate_exit_point(inv_cov_mat:mat3x3<f32>, ray: Ray, hit: HitInfo) -> vec3<f32> {
        //     // TODO: use the inv_cov_mat instead

        //     // Transform the ray into the ellipsoid's local space
        //     // let rotationMatrix = quaternion_to_matrix(hit.gaussian.rotation);
        //     // let transformedRayOrigin = (ray.origin - hit.gaussian.position) * rotationMatrix;
        //     // let transformedRayDirection = ray.direction * rotationMatrix;

        //     // // Scale the transformed ray to account for ellipsoid scaling
        //     // let scaledRayOrigin = transformedRayOrigin / hit.gaussian.scale;
        //     // let scaledRayDirection = transformedRayDirection / hit.gaussian.scale;

        //     // // Calculate the coefficients of the quadratic equation for the ellipsoid-ray intersection
        //     // // Note: These are the same as used in the entry point calculation, but we will use a different starting point for t
        //     // let A = dot(scaledRayDirection, scaledRayDirection);
        //     // let B = 2.0 * dot(scaledRayDirection, scaledRayOrigin);
        //     // let C = dot(scaledRayOrigin, scaledRayOrigin) - 1.0;
        //     let localRayOrigin = inv_cov_mat * (ray.origin - hit.gaussian.position);
        //     let localRayDirection = inv_cov_mat * ray.direction;

        //     // Compute coefficients of the quadratic equation for intersection with a unit sphere
        //     let a = dot(localRayDirection, localRayDirection);
        //     let b = 2.0 * dot(localRayDirection, localRayOrigin);
        //     let c = dot(localRayOrigin, localRayOrigin) - 1.0;

        //     // Solve the quadratic equation
        //     let discriminant = b * b - 4.0 * a * c;
        //     if (discriminant < 0.0) {
        //         // No exit point, return some default value or handle as an error
        //         return vec3f(0,0,0);
        //     }

        //     let t0 = (-b - sqrt(discriminant)) / (2.0 * a);
        //     let t1 = (-b + sqrt(discriminant)) / (2.0 * a);

        //     // The larger t value will be the exit point
        //     let t_exit = max(t0, t1);

        //     let exitPointLocal = localRayOrigin + t_exit * localRayDirection;

        //     // Transform the exit point back to world space
        //     let exitPointWorld = rotationMatrix * exitPointLocal + hit.gaussian.position;

        //     return exitPointWorld;
        // }


        fn intersect_ellipsoid(ray: ptr<function, Ray>, gaussian: Gaussian, inv_cov_mat:mat3x3<f32>, spherical_harmonics: array<vec3<f32>, 16>, hit: ptr<function, HitInfo>, material: Material) -> bool {
            let transformedRayOrigin = inv_cov_mat * ((*ray).origin - gaussian.position);
            let transformedRayDirection = inv_cov_mat * (*ray).direction;

            // Compute coefficients of the quadratic equation
            let a = dot(transformedRayDirection, transformedRayDirection);
            let b = 2.0 * dot(transformedRayDirection, transformedRayOrigin);
            let c = dot(transformedRayOrigin, transformedRayOrigin) - 1.0;

            let d: f32 = b * b - 4 * a * c;
            
            if (d < 0 ) { return false; }
            
            var t: f32;
            let t1: f32 = (-b - sqrt(d)) / (2.0 * a);
            let t2: f32 = (-b + sqrt(d)) / (2.0 * a);

            // t = min(t1,t2);
            if ((*ray).t_min < t1 && t1 < (*ray).t_max) {
                t = t1;
            } else if ((*ray).t_min < t2 && t2 < (*ray).t_max) {
                t = t2;
            } else {
                return false;
            }
            let hit_pos: vec3f = (*ray).origin + (*ray).direction * t;

            // Calculate the normal at the hit position
            let normal_at_hit: vec3f = normalize(inv_cov_mat * (hit_pos - gaussian.position));

            // Determine if the ray is entering or exiting the ellipsoid
            if (0.0 < dot((*ray).direction, normal_at_hit)) {
                // We're exiting the ellipsoid
                // (*hit).exit = hit_pos;
                return false;
            } else {
                // We're entering the ellipsoid
                (*hit).has_hit = true;
                (*hit).dist = t;
                (*hit).gaussian = gaussian;
                (*hit).position = hit_pos;

                (*hit).material = material; // TODO this is temporary, use spherical harmonics at some point
                (*hit).material.color = compute_color_from_sh(hit_pos, spherical_harmonics);
                (*hit).normal = normal_at_hit;
                (*hit).entry = hit_pos;
                (*hit).exit = calculate_exit_point(inv_cov_mat, *ray, *hit);
            }
            return (*hit).has_hit;
        }

        fn intersect_plane(ray: ptr<function, Ray>, plane: Plane, hit: ptr<function, HitInfo>) -> bool {
            let o_to_plane: vec3f = plane.position - (*ray).origin;
            let denominator = dot((*ray).direction, plane.normal);
            
            // The plane and the ray are parallel when the denominator gets close to 0
            if (abs(denominator) < uniforms.eps) {
                return false;
            }

            let t = dot(o_to_plane, plane.normal) / denominator;

            if (t < (*ray).t_min || (*ray).t_max < t) {
                return false;
            }
            
            // Update the hit info
            (*hit).has_hit = true;
            (*hit).dist = t;
            (*hit).material = plane.material;
            (*hit).position = (*ray).origin + (*ray).direction * t;
            (*hit).normal = normalize(plane.normal);
            (*hit).shader = 0;

            return true;
        }

        fn blend_alpha(accumulatedAlpha: f32, newAlpha: f32) -> f32 {
            // Implementing a standard over operator for alpha compositing
            return accumulatedAlpha + newAlpha * (1.0 - accumulatedAlpha);
        }

        const SH_C0 = 0.28209479177387814;
        const SH_C1 = 0.4886025119029199;
        const SH_C2 = array(
            1.0925484305920792,
            -1.0925484305920792,
            0.31539156525252005,
            -1.0925484305920792,
            0.5462742152960396
        );
        const SH_C3 = array(
            -0.5900435899266435f,
            2.890611442640554f,
            -0.4570457994644658f,
            0.3731763325901154f,
            -0.4570457994644658f,
            1.445305721320277f,
            -0.5900435899266435f
        );

        fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {
            let dir = normalize(position - uniforms.camera_position);
            var result = SH_C0 * sh[0];

            // if deg > 0
            let x = dir.x;
            let y = dir.y;
            let z = dir.z;

            result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);

            let xx = x * x;
            let yy = y * y;
            let zz = z * z;
            let xy = x * y;
            let xz = x * z;
            let yz = y * z;

            // if (sh_degree > 1) {
            result = result +
                SH_C2[0] * xy * sh[4] +
                SH_C2[1] * yz * sh[5] +
                SH_C2[2] * (2. * zz - xx - yy) * sh[6] +
                SH_C2[3] * xz * sh[7] +
                SH_C2[4] * (xx - yy) * sh[8];
            
            // if (sh_degree > 2) {
            result = result +
                SH_C3[0] * y * (3. * xx - yy) * sh[9] +
                SH_C3[1] * xy * z * sh[10] +
                SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +
                SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +
                SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +
                SH_C3[5] * z * (xx - yy) * sh[14] +
                SH_C3[6] * x * (xx - 3. * yy) * sh[15];

            // unconditional
            result = result + 0.5;

            return max(result, vec3<f32>(0.));
        }

        fn intersect_scene(ray: ptr<function, Ray>) -> vec3f {
            var shaded_result = vec3f();//BACKGROUNDCOLOR.rgb; //vec3f();
            let default_material: Material = Material();
            var gauss1_mat = default_material;
            var gauss2_mat = default_material;
            gauss1_mat.color = vec3f(.5, 0.0, 0.0);
            gauss2_mat.color = vec3f(0.0, 0.0, .5);

            var gauss1: Gaussian = Gaussian(
                vec3f(0,0,0),   // pos
                vec3f(1,1,1),   // normal
                .5,            // opacity
                vec3f(1,1,1),   // scale
                // vec4f(0, .3, 0, .7),    // rotation
                vec4f(0),    // rotation
                // gauss1_mat
            );
            var gauss2: Gaussian = Gaussian(
                vec3f(1,0,0),   // pos
                vec3f(1,1,1),   // normal
                .8,            // opacity
                vec3f(1,1,1),   // scale
                // vec4f(0, .3, 0, .7),    // rotation
                vec4f(0),    // rotation
                // gauss2_mat
            );
            var g = array<Gaussian, 2>(gauss1,gauss2);
            var inv = array<mat3x3<f32>, 2>(
                mat3x3<f32>(
                    30, 0, 0,
                    0, 30, 0,
                    0, 0, 30
                ),
                mat3x3<f32>(
                    1, 0, 0,
                    0, 1, 0,
                    0, 0, 1
                )
            );
            var m = array<Material, 2>(gauss1_mat, gauss2_mat);
            var intersections = array<HitInfo, MAXINTERSECTIONS>();
            var n_intersections: i32 = 0;
            
            // Testing of hard coded ellipsoids / spheres
            // for (var i: u32 = 0; i < 2; i++) {
            //     var hit = HitInfo();
            //     if (intersect_ellipsoid(ray, g[i], inv[i], &hit, m[i])) {
            //         intersections[n_intersections] = hit;
            //         n_intersections += 1;
            //     }
            // }
            
            // Check for hit against all ellipsoids - for now there are only N for testing
            for (var i: u32 = 0; i < 10000; i++) {
                var hit = HitInfo();
                if (intersect_ellipsoid(ray, gaussians[i], inv[0], spherical_harmonics[i], &hit, m[i%2])) {
                    intersections[n_intersections] = hit;
                    n_intersections += 1;
                }
            }

            // Model as spheres for testing
            // for (var i: u32 = 0; i < 10000; i++) {
            //     var hit = HitInfo();
            //     let sphere: Sphere = Sphere(
            //         gaussians[i].position,
            //         .05,//gaussians[i].scale.x,
            //         gauss1_mat,
            //         0 // shader
            //     );
            //     if (intersect_sphere(ray, sphere, &hit)) {
            //         intersections[n_intersections] = hit;
            //         n_intersections += 1;
            //     }
            // }
            
            // TODO: Real alpha blending
            // Iterate over the hits
            for (var i: i32 = n_intersections - 1; 0 <= i; i--) {
                // shaded_result += intersections[i].material.color * calculate_alpha(intersections[i]);
                // shaded_result += intersections[i].normal;
                shaded_result += intersections[i].material.color * calculate_alpha(intersections[i]);
            }

            return shaded_result;
        }

        // fn intersect_scene(ray: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> bool {
        //     // Scene description
        //     let default_material: Material = Material();
        //     var sphere_mat = default_material;
        //     var gauss1_mat = default_material;
        //     var gauss2_mat = default_material;
        //     var plane_mat = default_material;
        //     sphere_mat.color = vec3f(0.5, 0.0, 0.0);
        //     gauss1_mat.color = vec3f(0.5, 0.0, 0.0);
        //     gauss2_mat.color = vec3f(0.0, 0.0, 0.5);
        //     plane_mat.color = vec3f(.1);

        //     let sphere: Sphere = Sphere(
        //         vec3(2.5,0,0),
        //         1,
        //         sphere_mat,
        //         0 // shader
        //     );
        //     let plane = Plane(
        //         vec3f(0, 0, 0),
        //         vec3f(0, 0.0, -1.0),
        //         plane_mat
        //     );
        //     var gauss1: Gaussian = Gaussian(
        //         vec3f(0,0,0),   // pos
        //         vec3f(1,1,1),   // normal
        //         1.0,            // opacity
        //         vec3f(1,1,2),   // scale
        //         // vec4f(0, .3, 0, .7),    // rotation
        //         vec4f(0),    // rotation
        //         // gauss1_mat
        //     );
        //     var gauss2: Gaussian = Gaussian(
        //         vec3f(1,0,0),   // pos
        //         vec3f(1,1,1),   // normal
        //         1.0,            // opacity
        //         vec3f(1,1,2),   // scale
        //         // vec4f(0, .3, 0, .7),    // rotation
        //         vec4f(0),    // rotation
        //         // gauss2_mat
        //     );
        //     // rotates around the y-axis: vec4f(0.0, 0.7071067811865476, 0.0, 0.7071067811865475)
        //     // rotates around the z-axis: vec4f(0.0, 0.0, 0.7071067811865476, 0.7071067811865475)

        //     // if (intersect_sphere(ray, sphere, hit)) {
        //     //    (*ray).t_max = (*hit).dist;
        //     // }

        //     if (intersect_ellipsoid(ray, gauss2, hit, gauss2_mat)) {
        //         (*ray).t_max = (*hit).dist;
        //     }

        //     if (intersect_ellipsoid(ray, gauss1, hit, gauss1_mat)) {
        //         (*ray).t_max = (*hit).dist;
        //     }

            

        //     // if (intersect_plane(ray, plane, hit)) {
        //     //     (*ray).t_max = (*hit).dist;
        //     // }

        //     // This is the bottleneck - too many points takes forever
        //     // for (var index: u32 = 0; index < 100; index++) { // arrayLength(&gaussians)
        //     // //     if (intersect_ellipsoid(ray, gaussians[gaussian_ordering[index]], hit, gauss1_mat)) {
        //     // //         (*ray).t_max = (*hit).dist;
        //     // //     }
        //     // }

        //     // for (var index: u32 = 0; index < 2500; index++) { // arrayLength(&gaussians)
        //     //     let sphere: Sphere = Sphere(
        //     //         gaussians[index].position,
        //     //         // gaussians[gaussian_ordering[index]].position,
        //     //         0.025,
        //     //         sphere_mat,
        //     //         0 // mirror
        //     //     );

        //     //     // Points too close, temporary
        //     //     if (length(gaussians[index].position - uniforms.camera_position) < 2) {
        //     //         continue;
        //     //     }
        //     //     if (intersect_sphere(ray, sphere, hit)) {
        //     //        (*ray).t_max = (*hit).dist;
        //     //     }
        //     // }

        //     // var n_points: u32 = 0;
        //     // var max_points: u32 = 50000;
        //     // for (var index: u32 = 0; index < arrayLength(&gaussians); index++) { // arrayLength(&gaussians)
        //     //     let sphere: Sphere = Sphere(
        //     //         // gaussians[index].position,
        //     //         gaussians[gaussian_ordering[index]].position,
        //     //         0.025,
        //     //         sphere_mat,
        //     //         0 // mirror
        //     //     );

        //     //     // Points too close, temporary
        //     //     if (2 < length(sphere.center - uniforms.camera_position)) {
        //     //         if (intersect_sphere(ray, sphere, hit)) {
        //     //             (*ray).t_max = (*hit).dist;
        //     //         }
        //     //         n_points += 1;
        //     //     }
        //     //     if (max_points <= n_points) {
        //     //         break;
        //     //     }
        //     // }

        //     return (*hit).has_hit;
        // }

        // fn shade(ray: ptr<function, Ray>, hit: HitInfo) -> vec3f {            
        //     switch hit.shader {
        //         // Debugging flat objects etc.
        //         case 0 { return hit.material.color; }

        //         // Gaussians / ellipsoids
        //         case 1 {
        //             (*ray).origin = hit.position;
        //             (*ray).t_min = uniforms.eps;
        //             (*ray).t_max = TMAX;

        //             // If we are exiting the gauss
        //             if (length(hit.exit) != 0.0) {
        //                 let out = hit.material.color;// * calculate_alpha(hit);
        //                 return out;
        //                 // return vec3f();

        //             // We are just entering the gaussian
        //             } else {
        //                 return vec3f();
        //             }
        //         } 
        //         case default { return hit.material.color; }
        //     }
        // }

        // fn shade(ray: ptr<function, Ray>, hit: ptr<function, HitInfo>, seed: ptr<function, u32>) -> vec3f {            
        //     switch (*hit).shader {
        //         // Debugging flat objects etc.
        //         case 0 { return (*hit).material.color; }

        //         // Gaussians / ellipsoids
        //         case 1 {
        //             (*hit).has_hit = false;
        //             (*ray).origin = (*hit).position;
        //             (*ray).t_min = uniforms.eps;
        //             (*ray).t_max = TMAX;

        //             // If we are exiting the gauss
        //             if (length((*hit).exit) != 0.0) {
        //                 let out = (*hit).material.color * calculate_alpha(hit, (*hit).gaussian);
        //                 (*hit).exit = vec3f();
        //                 (*hit).entry = vec3f();
        //                 return out;

        //             // We are just entering the gaussian
        //             } else {
        //                 return vec3f();
        //             }
        //         } 
        //         case default { return (*hit).material.color; }
        //     }
        // }

        @fragment
        fn main_fs(@builtin(position) fragcoord: vec4f, @location(0) coords: vec2f) -> FSOut {
            let launch_idx: u32 = u32(fragcoord.y) * u32(uniforms.canvas_width) + u32(fragcoord.x); 
            var seed: u32 = tea(launch_idx, u32(uniforms.frame_number));
            var jitter: vec2f = vec2f(random(&seed), random(&seed)) / f32(uniforms.canvas_height);
            
            let jittered_coords = coords;// + jitter;

            let uv = vec2f(jittered_coords.x * uniforms.aspect_ratio * 0.5, jittered_coords.y * 0.5);

            let a = gaussians[0];
            let b = spherical_harmonics[0];
            var c = gaussian_ordering[0];
            var d = inv_covariance_matrices[0];

            var ray = get_camera_ray(uv);
            var hit = HitInfo();

            var shaded_result = intersect_scene(&ray);

            // var shaded_result = vec3f(0,0,0);

            // var intersections: array<HitInfo, MAXINTERSECTIONS> = intersect_scene(&ray);

            // for (var i: u32 = 0; i < MAXINTERSECTIONS; i++) {

            //     shaded_result += vec3f(0.5,0,0);//shade(&ray, intersections[i], &seed);
                
            //     // Way to check if we have hit the last intersection "stop-tag"
            //     if (!intersections[i].has_hit) {
            //         break;
            //     }
            // }

            // for (var i: u32 = 0; i < MAXINTERSECTIONS; i++) {
            //     if (intersect_scene(&ray, &hit)) {
            //         shaded_result += shade(&ray, &hit, &seed);
            //     } else {
            //         shaded_result += BACKGROUNDCOLOR.rgb;
            //         break;
            //     }
            //     if (hit.has_hit) {
            //         break;
            //     }
            // }
            
            let curr_sum = textureLoad(renderTexture, vec2u(fragcoord.xy), 0).rgb * f32(uniforms.frame_number); 
            var accum_color = (shaded_result + curr_sum)/(uniforms.frame_number + 1);

            return FSOut(
                // vec4f(pow(accum_color, vec3f(1.0/uniforms.gamma)), 1.0),
                vec4f(pow(shaded_result, vec3f(1.0/uniforms.gamma)), 1.0),
                vec4f(accum_color, 1.0)
            );
        }


        // PRNG xorshift seed generator by NVIDIA
        fn tea(val0: u32, val1: u32) -> u32 {
            const N = 16u; // User specified number of iterations
            var v0 = val0;
            var v1 = val1;
            var s0 = 0u;
            for (var n = 0u; n < N; n++) {
                s0 += 0x9e3779b9;
                v0 += ((v1<<4)+0xa341316c)^(v1+s0)^((v1>>5)+0xc8013ea4);
                v1 += ((v0<<4)+0xad90777d)^(v0+s0)^((v0>>5)+0x7e95761e);
            }
            return v0;
        }

        // Generate random unsigned int in [0, 2^31)
        fn mcg31(prev: ptr<function, u32>) -> u32 {
            const LCG_A = 1977654935u; // Multiplier from Hui-Ching Tang [EJOR 2007] 
            *prev = (LCG_A * (*prev)) & 0x7FFFFFFF;
            return *prev;
        }
        // Generate random float in [0, 1)
        fn random(prev: ptr<function, u32>) -> f32 {
            return f32(mcg31(prev)) / f32(0x80000000); 
        }


    </script>
</head>
<body>
    <input type="file" id="file-input" /><br>
    <pre id="file-content"></pre>

    <canvas id="webgpu-canvas" width=512 height=512>
        Error: Browser doesn't support HTML5 canvas
    </canvas>

    <!-------- Interface -------->
    <table>
        <!-- FPS Counter -->
        <tr>
            <td colspan="2">
                <label id="fps-label">FPS: --</label>
            </td>
        </tr>
        <!-- Zoom -->
        <tr>
            <td colspan="2">
                <!-- NOTE: oninput not supported in IE10, but nobody uses it and oninput gives nice smooth slide -->
                <input type="range" id="zoom-slider" name="zoom-slider" min="0.1" max="10" step ="0.1" value="3." list="markers" oninput=onZoomSliderChange(this.value)>
                <label id="zoom-label">Zoom: 1</label>
            </td>
        </tr>
        <!-- Update -->
        <tr>
            <td colspan="2">
                <input type="checkbox" id="progressive-update-checkbox" name="progressive-update-checkbox" onchange=onDoProgressiveUpdatesChange(this.checked)>
                <label for="progressive-update-checkbox">Use progressive updating</label>
            </td>
        </tr>
    </table>
</body>
</html>