<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <script type="text/javascript" src="PlyReader.js"></script> -->
    <script type="text/javascript" src="utils/MV.js"></script>
    <script type="text/javascript" src="utils/BspTree.js"></script>
    <script type="text/javascript" src="utils/Aabb.js"></script>
    <script type="text/javascript" src="utils/helpers.js"></script>
    <script type="text/javascript" src="app.js"></script>
    
    <script id="wgsl" type="x-shader"> 

        const PI: f32 = 3.14159265359;
        const INFINITY: f32 = 1.0e+38;
        
        const TMIN: f32 = 0.0;
        const TMAX: f32 = 1000.0;
        const MAXINTERSECTIONS: i32 = 50;
        const BACKGROUNDCOLOR: vec4f = vec4f(0.1, 0.3, 0.6, 1.0);

        const MAX_LEVEL: u32 = 20;
        const BSP_LEAF: u32 = 3;
        var<private> branch_node: array<vec2u, MAX_LEVEL>; 
        var<private> branch_ray: array<vec2f, MAX_LEVEL>;

        @group(0) @binding(0) var<uniform> uniforms : Uniforms;
        @group(0) @binding(1) var renderTexture: texture_2d<f32>;

        @group(0) @binding(2) var<storage, read> gaussians: array<Gaussian>;
        @group(0) @binding(3) var<storage, read> gaussian_ordering: array<u32>;
        // @group(0) @binding(4) var<storage, read> spherical_harmonics: array<SphericalHarmonics>;
        @group(0) @binding(4) var<storage, read> spherical_harmonics: array<array<vec3<f32>, 16>>;
        @group(0) @binding(5) var<storage, read> inv_covariance_matrices: array<mat3x3<f32>>;

        @group(0) @binding(6) var<uniform> aabb: AABB;
        @group(0) @binding(7) var<storage> tree_ids: array<u32>; 
        @group(0) @binding(8) var<storage> bsp_tree: array<vec4u>;
        @group(0) @binding(9) var<storage> bsp_planes: array<f32>;

        struct Uniforms {
            eps: f32,
            aspect_ratio: f32,
            gamma: f32,
            frame_number: f32,       // u32 in spirit, not possible in practice
            canvas_width: f32,       // u32 in spirit, not possible in practice
            canvas_height: f32,      // u32 in spirit, not possible in practice
            _padding1: f32,
            camera_const: f32,
            camera_position: vec3f,
            camera_look_point: vec3f,
            camera_up_vector: vec3f,
        };

        struct Gaussian {
            position: vec3f,
            scale: vec3f,
            rotation: vec4f,
            normal: vec4f,
        };

        // struct SphericalHarmonics {
        //     coeffs: array<vec3<f32>, 16>
        // };

        struct VSOut {
            @builtin(position) position: vec4f,
            @location(0) coords: vec2f
        };

        struct FSOut {
            @location(0) frame: vec4f, 
            @location(1) accum: vec4f
        };

        struct AABB {
            min: vec3f,
            max: vec3f
        };

        struct Ray {
            origin: vec3f,
            direction: vec3f,
            t_min: f32,
            t_max: f32
        };

        struct HitInfo {
            has_hit: bool, 
            dist: f32, 
            position: vec3f, 
            normal: vec3f, 
            material: Material,
            shader: u32,
            entry: vec3f,
            exit: vec3f,
            gaussian: Gaussian
        };

        struct Sphere {
            center: vec3f,
            radius: f32,
            material: Material,
            shader: u32
        };
                
        struct Material {
            color: vec3f,
            emission: vec3f,
            specular: vec3f,
            index_of_refraction: f32,
            specular_reflectance: f32,
            shininess: f32
        };

        struct Plane {
            position: vec3f,
            normal: vec3f,
            material: Material
        };


        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut {
            // Origin in bottom left corner (-1, -1). TODO: Move to js, the same for every vert
            const pos = array<vec2f, 4>(
                vec2f(-1.0, 1.0), 
                vec2f(-1.0, -1.0), 
                vec2f(1.0, 1.0), 
                vec2f(1.0, -1.0)
            );
            
            return VSOut(
                vec4f(pos[VertexIndex], 0.0, 1.0),
                pos[VertexIndex]
            );
        }

        fn get_camera_ray(uv: vec2f) -> Ray {
            // Create camera frame - following the procedure outlined in the book p.86
            let v: vec3f = normalize(uniforms.camera_look_point - uniforms.camera_position);
            let b1: vec3f = normalize(cross(v, uniforms.camera_up_vector));
            let b2: vec3f = cross(b1, v);

            return Ray(
                uniforms.camera_position,
                b1 * uv.x + b2 * uv.y + v * uniforms.camera_const,
                TMIN,
                TMAX
            );
        }

        fn intersect_sphere(ray: ptr<function, Ray>, sphere: Sphere, spherical_harmonics: array<vec3f, 16>, hit: ptr<function, HitInfo>) -> bool {            
            let o_to_sphere: vec3f = (*ray).origin - sphere.center;

            let a: f32 = dot((*ray).direction, (*ray).direction);
            let b: f32 = 2 * dot(o_to_sphere, (*ray).direction);
            let c: f32 = dot(o_to_sphere, o_to_sphere) - (sphere.radius * sphere.radius);

            let d: f32 = b * b - 4 * a * c;
            
            if (d < 0 ) { return false; }
            
            var t: f32;
            let t1: f32 = (-b - sqrt(d)) / (2.0 * a);
            let t2: f32 = (-b + sqrt(d)) / (2.0 * a);

            // if ((*ray).t_min < t1 && t1 < (*ray).t_max) {
            //     t = t1;
            // } else if ((*ray).t_min < t2 && t2 < (*ray).t_max) {
            //     t = t2;
            // } else {
            //     return false;
            // }


            // Update the hit info
            (*hit).has_hit = true;
            (*hit).dist = min(t1,t2);
            (*hit).entry = (*ray).origin + (*ray).direction * min(t1,t2);
            (*hit).exit = (*ray).origin + (*ray).direction * max(t1,t2);
            (*hit).material = sphere.material;
            (*hit).material.color = compute_color_from_sh((*hit).entry, spherical_harmonics);
            (*hit).normal = normalize((*hit).entry - sphere.center);
            (*hit).shader = sphere.shader;
            
            return true;
        }


        fn intersect_trimesh(ray: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> bool {
            var branch_lvl: u32 = 0;
            var near_node: u32 = 0;
            var far_node: u32 = 0;
            var t = 0.0;
            var node: u32 = 0;
            
            for (var i: u32 = 0; i <= MAX_LEVEL; i++) {
                let tree_node = bsp_tree[node];
                let node_axis_leaf = tree_node.x&3u;
                if (node_axis_leaf == BSP_LEAF) {
                    
                    // A leaf was found
                    let node_count = tree_node.x>>2u;
                    let node_id = tree_node.y;
                    var found = false;

                    for (var j: u32 = 0; j < node_count; j++) {
                        let obj_idx = tree_ids[node_id + j];
                        if (intersect_ellipsoid(ray, obj_idx, hit)) {
                            (*ray).t_max = (*hit).dist;
                            found = true;    
                        }
                    }
                    if (found) {
                        return true;
                    } else if (branch_lvl == 0u) {
                        return false;
                    } else {
                        branch_lvl--;
                        i = branch_node[branch_lvl].x;
                        node = branch_node[branch_lvl].y;
                        (*ray).t_min = branch_ray[branch_lvl].x;
                        (*ray).t_max = branch_ray[branch_lvl].y;
                        continue;
                    }
                    // ---
                }

                let axis_direction = (*ray).direction[node_axis_leaf]; 
                let axis_origin = (*ray).origin[node_axis_leaf]; 
                if (0.0 <= axis_direction) {
                    near_node = tree_node.z;    // left
                    far_node = tree_node.w;     // right
                } else {
                    near_node = tree_node.w;    // right
                    far_node = tree_node.z;     // left
                }
                let node_plane = bsp_planes[node];
                let denom = select(axis_direction, 1.0e-8f, abs(axis_direction) < 1.0e-8f); 
                t = (node_plane - axis_origin)/denom;
                if (t > (*ray).t_max) { 
                    node = near_node; 
                } else if (t < (*ray).t_min) { 
                    node = far_node; 
                } else {
                    branch_node[branch_lvl].x = i; 
                    branch_node[branch_lvl].y = far_node; 
                    branch_ray[branch_lvl].x = t; 
                    branch_ray[branch_lvl].y = (*ray).t_max; 
                    branch_lvl++;
                    (*ray).t_max = t;
                    node = near_node; 
                }
            }
            return false;
        }
        

        fn quaternion_to_matrix(q: vec4f) -> mat3x3<f32> {
            // See: "Quaternion-derived rotation matrix" https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation 
            let xx = q.x * q.x;
            let yy = q.y * q.y;
            let zz = q.z * q.z;
            let xy = q.x * q.y;
            let xz = q.x * q.z;
            let yz = q.y * q.z;
            let wx = q.w * q.x;
            let wy = q.w * q.y;
            let wz = q.w * q.z;

            return mat3x3<f32>(
                vec3<f32>(1.0 - 2.0 * (yy + zz), 2.0 * (xy - wz), 2.0 * (xz + wy)),
                vec3<f32>(2.0 * (xy + wz), 1.0 - 2.0 * (xx + zz), 2.0 * (yz - wx)),
                vec3<f32>(2.0 * (xz - wy), 2.0 * (yz + wx), 1.0 - 2.0 * (xx + yy))
            );
        }

        fn rotate_vector(v: vec3<f32>, rotation_matrix: mat3x3<f32>) -> vec3<f32> {
            return rotation_matrix * v;
        }


        fn density_at_point(hit: HitInfo, inv_cov_mat: mat3x3<f32>) -> f32 {
            // Transform the point into the Gaussian's local space
            let localPoint = inv_cov_mat * (hit.position - hit.gaussian.position);

            // Compute the Gaussian density
            let density = exp(-0.5 * dot(localPoint, localPoint));
            return density;
            // return exp(-0.5 * transpose(hit.position))
        }

        fn calculate_alpha(hit: HitInfo) -> f32 {
            let midPoint: vec3f = (hit.entry + hit.exit) * 0.5;
            let distanceFromCenter: f32 = length(midPoint - hit.gaussian.position);
            let sigma: f32 = length(hit.gaussian.scale) / 2.0;  // Assuming uniform scale for simplicity
            let alphaAtMidPoint: f32 = exp(-distanceFromCenter * distanceFromCenter / (2.0 * sigma * sigma));
            
            let pathLength: f32 = length(hit.exit - hit.entry);
            let totalAlpha: f32 = alphaAtMidPoint * pathLength;  // Approximate total alpha
            return totalAlpha;
        }

        fn inverseRotateVector(v: vec3<f32>, q: vec4<f32>) -> vec3<f32> {
            let rotationMatrix = quaternion_to_matrix(q);
            let inverseRotationMatrix = transpose(rotationMatrix);
            return inverseRotationMatrix * v;
        }


        fn intersect_ellipsoid(ray: ptr<function, Ray>, id: u32, hit: ptr<function, HitInfo>) -> bool {            
            let gaussian: Gaussian = gaussians[id];
            let spherical_harmonics: array<vec3f,16> = spherical_harmonics[id];
            let translatedRayOrigin = (*ray).origin - gaussian.position;
            
            // Apply inverse rotation to the ray to align with the ellipsoid's axes
            let rotatedRayOrigin = inverseRotateVector(translatedRayOrigin, gaussian.rotation);
            let rotatedRayDirection = inverseRotateVector((*ray).direction, gaussian.rotation);

            // Scale the ray for the ellipsoid's local space
            let originNormalized = rotatedRayOrigin / gaussian.scale;
            let directionNormalized = rotatedRayDirection / gaussian.scale;
            let a = dot(directionNormalized, directionNormalized);
            let b = dot(originNormalized, directionNormalized);
            let c = dot(originNormalized, originNormalized);
            let discriminant = b * b - a * (c - 1.0);
            if (discriminant < 0.0) {
                return false;
            }

            let sqrtDiscriminant = sqrt(discriminant);
            let t1 = (-b - sqrtDiscriminant) / a;
            let t2 = (-b + sqrtDiscriminant) / a;

            (*hit).gaussian = gaussian;
            (*hit).material = Material();
            (*hit).entry = (*ray).origin + (*ray).direction * min(t1,t2);
            (*hit).exit = (*ray).origin + (*ray).direction * max(t1,t2);
            (*hit).material.color = compute_color_from_sh((*hit).entry, spherical_harmonics);

            return true;
        }
        

        fn blend_alpha(accumulatedAlpha: f32, newAlpha: f32) -> f32 {
            // Implementing a standard over operator for alpha compositing
            return accumulatedAlpha + newAlpha * (1.0 - accumulatedAlpha);
        }

        const SH_C0 = 0.28209479177387814;
        const SH_C1 = 0.4886025119029199;
        const SH_C2 = array(
            1.0925484305920792,
            -1.0925484305920792,
            0.31539156525252005,
            -1.0925484305920792,
            0.5462742152960396
        );
        const SH_C3 = array(
            -0.5900435899266435,
            2.890611442640554,
            -0.4570457994644658,
            0.3731763325901154,
            -0.4570457994644658,
            1.445305721320277,
            -0.5900435899266435
        );

        fn compute_color_from_sh(position: vec3<f32>, sh: array<vec3<f32>, 16>) -> vec3<f32> {
            let dir = normalize(position - uniforms.camera_position);
            var result = SH_C0 * sh[0];

            // if deg > 0
            let x = dir.x;
            let y = dir.y;
            let z = dir.z;

            result = result + SH_C1 * (-y * sh[1] + z * sh[2] - x * sh[3]);

            let xx = x * x;
            let yy = y * y;
            let zz = z * z;
            let xy = x * y;
            let xz = x * z;
            let yz = y * z;

            // if (sh_degree > 1) {
            result = result +
                SH_C2[0] * xy * sh[4] +
                SH_C2[1] * yz * sh[5] +
                SH_C2[2] * (2. * zz - xx - yy) * sh[6] +
                SH_C2[3] * xz * sh[7] +
                SH_C2[4] * (xx - yy) * sh[8];
            
            // if (sh_degree > 2) {
            result = result +
                SH_C3[0] * y * (3. * xx - yy) * sh[9] +
                SH_C3[1] * xy * z * sh[10] +
                SH_C3[2] * y * (4. * zz - xx - yy) * sh[11] +
                SH_C3[3] * z * (2. * zz - 3. * xx - 3. * yy) * sh[12] +
                SH_C3[4] * x * (4. * zz - xx - yy) * sh[13] +
                SH_C3[5] * z * (xx - yy) * sh[14] +
                SH_C3[6] * x * (xx - 3. * yy) * sh[15];

            // unconditional
            result = result + 0.5;

            return max(result, vec3<f32>(0.));
        }

        fn intersect_scene(ray: ptr<function, Ray>) -> vec3f {
            var shaded_result = vec3f();//BACKGROUNDCOLOR.rgb; //vec3f();
            let default_material: Material = Material();
            var gauss1_mat = default_material;
            var gauss2_mat = default_material;
            gauss1_mat.color = vec3f(.5, 0.0, 0.0);
            gauss2_mat.color = vec3f(0.0, 0.0, .5);

            var gauss1: Gaussian = Gaussian(
                vec3f(0,0,0),   // pos
                vec3f(1,1,3),   // scale
                vec4f(0.7,0,0,0.7),    // rotation
                vec4f(1,1,1, 1),   // normal
                // normalize(vec4f(0.5,0,1)),    // rotation
                // gauss1_mat
            );
            var gauss2: Gaussian = Gaussian(
                vec3f(1,0,0),   // pos
                vec3f(1,1,3),   // scale
                // vec4f(0),    // rotation
                vec4f(.7,0,0,0.7),    // rotation
                vec4f(1,1,1, 0.8),   // normal
                // gauss2_mat
            );
            var g = array<Gaussian, 2>(gauss1,gauss2);
            var m = array<Material, 2>(gauss1_mat, gauss2_mat);
            var intersections = array<HitInfo, MAXINTERSECTIONS>();
            var n_intersections: i32 = 0;
            
            // Testing of hard coded ellipsoids / spheres
            // for (var i: u32 = 0; i < 2; i++) {
            //     var hit = HitInfo();
            //     if (intersect_ellipsoid(ray, i, &hit, m[i])) {
            //         intersections[n_intersections] = hit;
            //         n_intersections += 1;
            //     }
            // }
            
            // Check for hit against all ellipsoids - for now there are only N for testing
            // Higher than 50000 fails, can hopefully be solved with a BVH
            // for (var i: u32 = 0; i < 50000; i++) {
            //     if (MAXINTERSECTIONS - 1 <= n_intersections) {
            //         continue;
            //     }
            //     var hit = HitInfo();
            //     if (intersect_ellipsoid(ray, i, &hit, m[i%2])) {
            //         // if (2 < length(hit.entry - uniforms.camera_position)) {
            //             intersections[n_intersections] = hit;
            //             n_intersections += 1;
            //         // }
            //     }
            // }
            var hit = HitInfo();
            if (intersect_trimesh(ray, &hit)) {
                intersections[n_intersections] = hit;
                n_intersections += 1;
            }

            // Model as spheres for testing
            // for (var i: u32 = 0; i < 50000; i++) {
            //     var hit = HitInfo();
            //     let sphere: Sphere = Sphere(
            //         gaussians[i].position,
            //         0.025,
            //         m[i%2],
            //         0 // shader
            //     );
            //     if (intersect_sphere(ray, sphere, spherical_harmonics[i], &hit)) {
            //         intersections[n_intersections] = hit;
            //         n_intersections += 1;
            //     }
            // }
            
            // TODO: Real alpha blending
            // Iterate over the hits
            for (var i: i32 = n_intersections - 1; 0 <= i; i--) {
                // shaded_result += intersections[i].material.color;
                // shaded_result += intersections[i].normal;
                shaded_result += intersections[i].material.color * calculate_alpha(intersections[i]);
            }
            // shaded_result = intersections[n_intersections - 1].material.color;
            // shaded_result = intersections[0].gaussian.normal.rgb;

            return shaded_result;
        }

        @fragment
        fn main_fs(@builtin(position) fragcoord: vec4f, @location(0) coords: vec2f) -> FSOut {
            let launch_idx: u32 = u32(fragcoord.y) * u32(uniforms.canvas_width) + u32(fragcoord.x); 
            var seed: u32 = tea(launch_idx, u32(uniforms.frame_number));
            var jitter: vec2f = vec2f(random(&seed), random(&seed)) / f32(uniforms.canvas_height);
            
            let jittered_coords = coords;// + jitter;

            let uv = vec2f(jittered_coords.x * uniforms.aspect_ratio * 0.5, jittered_coords.y * 0.5);

            let a = gaussians[0];
            let b = spherical_harmonics[0];
            var c = gaussian_ordering[0];
            var d = inv_covariance_matrices[0];

            var e = aabb;
            var f = tree_ids[0];
            var g = bsp_tree[0];
            var h = bsp_planes[0];

            var ray = get_camera_ray(uv);
            var hit = HitInfo();

            var shaded_result = intersect_scene(&ray);
            
            let curr_sum = textureLoad(renderTexture, vec2u(fragcoord.xy), 0).rgb * f32(uniforms.frame_number); 
            var accum_color = (shaded_result + curr_sum)/(uniforms.frame_number + 1);

            return FSOut(
                // vec4f(pow(accum_color, vec3f(1.0/uniforms.gamma)), 1.0),
                vec4f(pow(shaded_result, vec3f(1.0/uniforms.gamma)), 1.0),
                vec4f(accum_color, 1.0)
            );
        }


        // PRNG xorshift seed generator by NVIDIA
        fn tea(val0: u32, val1: u32) -> u32 {
            const N = 16u; // User specified number of iterations
            var v0 = val0;
            var v1 = val1;
            var s0 = 0u;
            for (var n = 0u; n < N; n++) {
                s0 += 0x9e3779b9;
                v0 += ((v1<<4)+0xa341316c)^(v1+s0)^((v1>>5)+0xc8013ea4);
                v1 += ((v0<<4)+0xad90777d)^(v0+s0)^((v0>>5)+0x7e95761e);
            }
            return v0;
        }

        // Generate random unsigned int in [0, 2^31)
        fn mcg31(prev: ptr<function, u32>) -> u32 {
            const LCG_A = 1977654935u; // Multiplier from Hui-Ching Tang [EJOR 2007] 
            *prev = (LCG_A * (*prev)) & 0x7FFFFFFF;
            return *prev;
        }
        // Generate random float in [0, 1)
        fn random(prev: ptr<function, u32>) -> f32 {
            return f32(mcg31(prev)) / f32(0x80000000); 
        }


    </script>
</head>
<body>
    <input type="file" id="file-input" /><br>
    <pre id="file-content"></pre>

    <canvas id="webgpu-canvas" width=512 height=512>
        Error: Browser doesn't support HTML5 canvas
    </canvas>

    <!-------- Interface -------->
    <table>
        <!-- FPS Counter -->
        <tr>
            <td colspan="2">
                <label id="fps-label">FPS: --</label>
            </td>
        </tr>
        <!-- Zoom -->
        <tr>
            <td colspan="2">
                <!-- NOTE: oninput not supported in IE10, but nobody uses it and oninput gives nice smooth slide -->
                <input type="range" id="zoom-slider" name="zoom-slider" min="0.1" max="10" step ="0.1" value="3." list="markers" oninput=onZoomSliderChange(this.value)>
                <label id="zoom-label">Zoom: 1</label>
            </td>
        </tr>
        <!-- Update -->
        <tr>
            <td colspan="2">
                <input type="checkbox" id="progressive-update-checkbox" name="progressive-update-checkbox" onchange=onDoProgressiveUpdatesChange(this.checked)>
                <label for="progressive-update-checkbox">Use progressive updating</label>
            </td>
        </tr>
    </table>
</body>
</html>