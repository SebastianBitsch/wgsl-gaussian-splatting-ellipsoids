<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <script type="text/javascript" src="PlyReader.js"></script> -->
    <script type="text/javascript" src="utils/MV.js"></script>
    <script type="text/javascript" src="utils/helpers.js"></script>
    <script type="text/javascript" src="app.js"></script>
    
    <script id="wgsl" type="x-shader"> 

        const PI: f32 = 3.14159265359;
        const INFINITY: f32 = 1.0e+38;
        
        const TMIN: f32 = 0.0;
        const TMAX: f32 = 100000.0;
        const MAXBOUNCES: u32 = 10;
        const BACKGROUNDCOLOR: vec4f = vec4f(0.0); //vec4f(0.1, 0.3, 0.6, 1.0);

        const MAX_LEVEL: u32 = 20;
        const BSP_LEAF: u32 = 3;
        var<private> branch_node: array<vec2u, MAX_LEVEL>; 
        var<private> branch_ray: array<vec2f, MAX_LEVEL>;

        @group(0) @binding(0) var<uniform> uniforms : Uniforms;
        @group(0) @binding(1) var renderTexture: texture_2d<f32>;

        @group(0) @binding(2) var<storage, read> gaussians: array<Gaussian>;
        @group(0) @binding(3) var<storage, read> spherical_harmonics: array<SphericalHarmonics>;


        struct Uniforms {
            eps: f32,
            aspect_ratio: f32,
            gamma: f32,
            frame_number: f32,       // u32 in spirit, not possible in practice
            canvas_width: f32,       // u32 in spirit, not possible in practice
            canvas_height: f32,      // u32 in spirit, not possible in practice
            _padding1: f32,
            camera_const: f32,
            camera_position: vec3f,
            camera_look_point: vec3f,
            camera_up_vector: vec3f,
        };

        struct Gaussian {
            position: vec3f,
            normal: vec3f,
            opacity: f32,
            scale: vec3f,
            rotation: vec4f,
            material: Material // TODO: THIS is temporary for debugging
        };

        struct SphericalHarmonics {
            coeffs: array<vec3<f32>, 16>
        };

        struct VSOut {
            @builtin(position) position: vec4f,
            @location(0) coords: vec2f
        };

        struct FSOut {
            @location(0) frame: vec4f, 
            @location(1) accum: vec4f
        };

        struct Ray {
            origin: vec3f,
            direction: vec3f,
            t_min: f32,
            t_max: f32
        };

        struct HitInfo {
            has_hit: bool, 
            dist: f32, 
            position: vec3f, 
            normal: vec3f, 
            material: Material,
            shader: u32,
            entry: vec3f,
            exit: vec3f,
            gaussian: Gaussian
        };

        struct Sphere {
            center: vec3f,
            radius: f32,
            material: Material,
            shader: u32
        };
                
        struct Material {
            color: vec3f,
            emission: vec3f,
            specular: vec3f,
            index_of_refraction: f32,
            specular_reflectance: f32,
            shininess: f32
        };

        struct Plane {
            position: vec3f,
            normal: vec3f,
            material: Material
        };


        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut {
            // Origin in bottom left corner (-1, -1). TODO: Move to js, the same for every vert
            const pos = array<vec2f, 4>(
                vec2f(-1.0, 1.0), 
                vec2f(-1.0, -1.0), 
                vec2f(1.0, 1.0), 
                vec2f(1.0, -1.0)
            );
            
            return VSOut(
                vec4f(pos[VertexIndex], 0.0, 1.0),
                pos[VertexIndex]
            );
        }

        fn get_camera_ray(uv: vec2f) -> Ray {
            // Create camera frame - following the procedure outlined in the book p.86
            let v: vec3f = normalize(uniforms.camera_look_point - uniforms.camera_position);
            let b1: vec3f = normalize(cross(v, uniforms.camera_up_vector));
            let b2: vec3f = cross(b1, v);

            return Ray(
                uniforms.camera_position,
                b1 * uv.x + b2 * uv.y + v * uniforms.camera_const,
                TMIN,
                TMAX
            );
        }

        fn intersect_sphere(ray: ptr<function, Ray>, sphere: Sphere, hit: ptr<function, HitInfo>) -> bool {            
            let o_to_sphere: vec3f = (*ray).origin - sphere.center;

            let a: f32 = dot((*ray).direction, (*ray).direction);
            let b: f32 = 2 * dot(o_to_sphere, (*ray).direction);
            let c: f32 = dot(o_to_sphere, o_to_sphere) - (sphere.radius * sphere.radius);

            let d: f32 = b * b - 4 * a * c;
            
            if (d < 0 ) { return false; }
            
            var t: f32;
            let t1: f32 = (-b - sqrt(d)) / (2.0 * a);
            let t2: f32 = (-b + sqrt(d)) / (2.0 * a);

            if ((*ray).t_min < t1 && t1 < (*ray).t_max) {
                t = t1;
            } else if ((*ray).t_min < t2 && t2 < (*ray).t_max) {
                t = t2;
            } else {
                return false;
            }

            let hit_pos: vec3f = (*ray).origin + (*ray).direction * t;

            // Update the hit info
            (*hit).has_hit = true;
            (*hit).dist = t;
            (*hit).material = sphere.material;
            (*hit).position = hit_pos;
            (*hit).normal = normalize(hit_pos - sphere.center);
            (*hit).shader = sphere.shader;

            // We hit the inside of the sphere, flip normal
            if (0.0 < dot((*ray).direction, (*hit).normal)) {
                (*hit).normal = -(*hit).normal;
            }
            
            return true;
        }


        fn quaternion_to_matrix(q: vec4<f32>) -> mat3x3<f32> {
            // See: "Quaternion-derived rotation matrix" https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation 
            let xx = q.x * q.x;
            let yy = q.y * q.y;
            let zz = q.z * q.z;
            let xy = q.x * q.y;
            let xz = q.x * q.z;
            let yz = q.y * q.z;
            let wx = q.w * q.x;
            let wy = q.w * q.y;
            let wz = q.w * q.z;

            return mat3x3<f32>(
                vec3<f32>(1.0 - 2.0 * (yy + zz), 2.0 * (xy - wz), 2.0 * (xz + wy)),
                vec3<f32>(2.0 * (xy + wz), 1.0 - 2.0 * (xx + zz), 2.0 * (yz - wx)),
                vec3<f32>(2.0 * (xz - wy), 2.0 * (yz + wx), 1.0 - 2.0 * (xx + yy))
            );
        }

        fn rotate_vector(normal: vec3<f32>, rotation_matrix: mat3x3<f32>) -> vec3<f32> {
            return rotation_matrix * normal;
        }

        // Function to calculate normal for a rotated ellipsoid
        fn calculate_rotated_normal(hit_pos: vec3<f32>, gaussian: Gaussian) -> vec3<f32> {
            // Calculate the rotation matrix from the quaternion
            let rotation_matrix = quaternion_to_matrix(gaussian.rotation);
            
            // Inverse rotation is the transpose of the rotation matrix
            let inverse_rotation_matrix = transpose(rotation_matrix);
            
            // Transform the hit position into the local space of the ellipsoid
            let local_hit_pos = rotate_vector(hit_pos - gaussian.position, inverse_rotation_matrix);
            
            // Calculate the normal in local space
            let local_normal = normalize(vec3(
                local_hit_pos.x / (gaussian.scale.x * gaussian.scale.x),
                local_hit_pos.y / (gaussian.scale.y * gaussian.scale.y),
                local_hit_pos.z / (gaussian.scale.z * gaussian.scale.z)
            ));
            
            // Rotate the normal back to world space
            let world_normal = rotate_vector(local_normal, rotation_matrix);
            
            return world_normal;
        }        


        fn calculate_alpha(hit: ptr<function, HitInfo>, gaussian: Gaussian) -> f32 {
            let midPoint: vec3f = ((*hit).entry + (*hit).exit) * 0.5;
            let distanceFromCenter: f32 = length(midPoint - gaussian.position);
            let sigma: f32 = length(gaussian.scale) / 2.0;  // Assuming uniform scale for simplicity
            let alphaAtMidPoint: f32 = exp(-distanceFromCenter * distanceFromCenter / (2.0 * sigma * sigma));
            
            let pathLength: f32 = length((*hit).exit - (*hit).entry);
            let totalAlpha: f32 = alphaAtMidPoint * pathLength;  // Approximate total alpha
            return totalAlpha;
        }


        fn intersect_ellipsoid(ray: ptr<function, Ray>, gaussian: Gaussian, hit: ptr<function, HitInfo>) -> bool {
            // Convert quaternion to rotation matrix
            let rotationMatrix = quaternion_to_matrix(gaussian.rotation);

            // Transform ray to ellipsoid's local space
            let transformedRayOrigin = ((*ray).origin - gaussian.position) * rotationMatrix;
            let transformedRayDirection = (*ray).direction * rotationMatrix;

            // Scale the transformed ray to account for ellipsoid scaling
            let scaledRayOrigin = transformedRayOrigin / gaussian.scale;
            let scaledRayDirection = transformedRayDirection / gaussian.scale;

            // Compute coefficients of the quadratic equation
            let a = dot(scaledRayDirection, scaledRayDirection);
            let b = 2.0 * dot(scaledRayDirection, scaledRayOrigin);
            let c = dot(scaledRayOrigin, scaledRayOrigin) - 1.0;

            let d: f32 = b * b - 4 * a * c;
            
            if (d < 0 ) { return false; }
            
            var t: f32;
            let t1: f32 = (-b - sqrt(d)) / (2.0 * a);
            let t2: f32 = (-b + sqrt(d)) / (2.0 * a);

            if ((*ray).t_min < t1 && t1 < (*ray).t_max) {
                t = t1;
            } else if ((*ray).t_min < t2 && t2 < (*ray).t_max) {
                t = t2;
            } else {
                return false;
            }
            let hit_pos: vec3f = (*ray).origin + (*ray).direction * t;

            // Calculate color and opacity based on Gaussian parameters
            (*hit).has_hit = true;
            (*hit).dist = t;
            (*hit).gaussian = gaussian;
            (*hit).position = hit_pos;
            (*hit).material = gaussian.material;
            (*hit).shader = 1;

            // Calculate the normal at the hit position
            let normal_at_hit: vec3f = calculate_rotated_normal(hit_pos, gaussian);

            // Determine if the ray is entering or exiting the ellipsoid
            if (0.0 < dot((*ray).direction, normal_at_hit)) {
                // We're exiting the ellipsoid
                (*hit).normal = -normal_at_hit;  // Flip the normal
                (*hit).exit = hit_pos;
            } else {
                // We're entering the ellipsoid
                (*hit).normal = normal_at_hit;
                (*hit).entry = hit_pos;
            }

            return (*hit).has_hit;
        }

        fn intersect_plane(ray: ptr<function, Ray>, plane: Plane, hit: ptr<function, HitInfo>) -> bool {
            let o_to_plane: vec3f = plane.position - (*ray).origin;
            let denominator = dot((*ray).direction, plane.normal);
            
            // The plane and the ray are parallel when the denominator gets close to 0
            if (abs(denominator) < uniforms.eps) {
                return false;
            }

            let t = dot(o_to_plane, plane.normal) / denominator;

            if (t < (*ray).t_min || (*ray).t_max < t) {
                return false;
            }
            
            // Update the hit info
            (*hit).has_hit = true;
            (*hit).dist = t;
            (*hit).material = plane.material;
            (*hit).position = (*ray).origin + (*ray).direction * t;
            (*hit).normal = normalize(plane.normal);
            (*hit).shader = 0;

            return true;
        }


        fn intersect_scene(ray: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> bool {
            // Scene description
            let default_material: Material = Material();
            var sphere_mat = default_material;
            var gauss1_mat = default_material;
            var gauss2_mat = default_material;
            var plane_mat = default_material;
            sphere_mat.color = vec3f(0.5, 0.0, 0.0);
            gauss1_mat.color = vec3f(0.5, 0.0, 0.0);
            gauss2_mat.color = vec3f(0.0, 0.0, 0.5);
            plane_mat.color = vec3f(.1);

            let sphere: Sphere = Sphere(
                vec3(2.5,0,0),
                1,
                sphere_mat,
                0 // shader
            );
            let plane = Plane(
                vec3f(0, 0, 0),
                vec3f(0, 0.0, -1.0),
                plane_mat
            );
            var gauss1: Gaussian = Gaussian(
                vec3f(0,0,0),   // pos
                vec3f(1,1,1),   // normal
                1.0,            // opacity
                vec3f(1,1,2),   // scale
                vec4f(0, .3, 0, .7),    // rotation
                gauss1_mat
            );
            var gauss2: Gaussian = Gaussian(
                vec3f(0,5,0),   // pos
                vec3f(1,1,1),   // normal
                1.0,            // opacity
                vec3f(1,1,2),   // scale
                vec4f(0, .3, 0, .7),    // rotation
                gauss2_mat
            );
            // rotates around the y-axis: vec4f(0.0, 0.7071067811865476, 0.0, 0.7071067811865475)
            // rotates around the z-axis: vec4f(0.0, 0.0, 0.7071067811865476, 0.7071067811865475)

            if (intersect_ellipsoid(ray, gauss2, hit)) {
                (*ray).t_max = (*hit).dist;
            }

            if (intersect_ellipsoid(ray, gauss1, hit)) {
                (*ray).t_max = (*hit).dist;
            }

            if (intersect_sphere(ray, sphere, hit)) {
               (*ray).t_max = (*hit).dist;
            }

            // if (intersect_plane(ray, plane, hit)) {
            //     (*ray).t_max = (*hit).dist;
            // }

            // This is the bottleneck - too many points takes forever
            // for (var index: u32 = 0; index < 100; index++) { // arrayLength(&gaussians)
            //     let sphere: Sphere = Sphere(
            //         gaussians[index].position,
            //         0.025,
            //         sphere_mat,
            //         0 // mirror
            //     );
            //     // if (intersect_sphere(ray, sphere, hit)) {
            //     //    (*ray).t_max = (*hit).dist;
            //     // }
            //     if (intersect_ellipsoid(ray, gaussians[index], hit)) {
            //         (*ray).t_max = (*hit).dist;
            //     }
            // }

            return (*hit).has_hit;
        }

        fn shade(ray: ptr<function, Ray>, hit: ptr<function, HitInfo>, seed: ptr<function, u32>) -> vec3f {            
            switch (*hit).shader {
                // Debugging flat objects etc.
                case 0 { return (*hit).material.color; }

                // Gaussians / ellipsoids
                case 1 {
                    (*hit).has_hit = false;
                    (*ray).origin = (*hit).position;
                    (*ray).t_min = uniforms.eps;
                    (*ray).t_max = TMAX;

                    // If we are exiting the gauss
                    if (length((*hit).exit) != 0.0) {;
                        let out = (*hit).material.color * calculate_alpha(hit, (*hit).gaussian);
                        (*hit).exit = vec3f();
                        (*hit).entry = vec3f();
                        return out;

                    // We are just entering the gaussian
                    } else {
                        return vec3f();
                    }
                } 
                case default { return (*hit).material.color; }
            }
        }

        @fragment
        fn main_fs(@builtin(position) fragcoord: vec4f, @location(0) coords: vec2f) -> FSOut {
            let launch_idx: u32 = u32(fragcoord.y) * u32(uniforms.canvas_width) + u32(fragcoord.x); 
            var seed: u32 = tea(launch_idx, u32(uniforms.frame_number));
            var jitter: vec2f = vec2f(random(&seed), random(&seed)) / f32(uniforms.canvas_height);
            
            let jittered_coords = coords;// + jitter;

            let uv = vec2f(jittered_coords.x * uniforms.aspect_ratio * 0.5, jittered_coords.y * 0.5);

            let a = gaussians[0];
            let b = spherical_harmonics[0];

            var ray = get_camera_ray(uv);
            var hit = HitInfo();

            var shaded_result = vec3f(0,0,0);

            for (var i: u32 = 0; i < MAXBOUNCES; i++) {
                if (intersect_scene(&ray, &hit)) {
                    shaded_result += shade(&ray, &hit, &seed);
                } else {
                    shaded_result += BACKGROUNDCOLOR.rgb;
                    break;
                }
                if (hit.has_hit) {
                    break;
                }
            }
            
            let curr_sum = textureLoad(renderTexture, vec2u(fragcoord.xy), 0).rgb * f32(uniforms.frame_number); 
            var accum_color = (shaded_result + curr_sum)/(uniforms.frame_number + 1);

            return FSOut(
                // vec4f(pow(accum_color, vec3f(1.0/uniforms.gamma)), 1.0),
                vec4f(pow(shaded_result, vec3f(1.0/uniforms.gamma)), 1.0),
                vec4f(accum_color, 1.0)
            );
        }


        // PRNG xorshift seed generator by NVIDIA
        fn tea(val0: u32, val1: u32) -> u32 {
            const N = 16u; // User specified number of iterations
            var v0 = val0;
            var v1 = val1;
            var s0 = 0u;
            for (var n = 0u; n < N; n++) {
                s0 += 0x9e3779b9;
                v0 += ((v1<<4)+0xa341316c)^(v1+s0)^((v1>>5)+0xc8013ea4);
                v1 += ((v0<<4)+0xad90777d)^(v0+s0)^((v0>>5)+0x7e95761e);
            }
            return v0;
        }

        // Generate random unsigned int in [0, 2^31)
        fn mcg31(prev: ptr<function, u32>) -> u32 {
            const LCG_A = 1977654935u; // Multiplier from Hui-Ching Tang [EJOR 2007] 
            *prev = (LCG_A * (*prev)) & 0x7FFFFFFF;
            return *prev;
        }
        // Generate random float in [0, 1)
        fn random(prev: ptr<function, u32>) -> f32 {
            return f32(mcg31(prev)) / f32(0x80000000); 
        }


    </script>
</head>
<body>
    <input type="file" id="file-input" /><br>
    <pre id="file-content"></pre>

    <canvas id="webgpu-canvas" width=512 height=512>
        Error: Browser doesn't support HTML5 canvas
    </canvas>

    <!-------- Interface -------->
    <table>
        <!-- FPS Counter -->
        <tr>
            <td colspan="2">
                <label id="fps-label">FPS: --</label>
            </td>
        </tr>
        <!-- Zoom -->
        <tr>
            <td colspan="2">
                <!-- NOTE: oninput not supported in IE10, but nobody uses it and oninput gives nice smooth slide -->
                <input type="range" id="zoom-slider" name="zoom-slider" min="0.1" max="10" step ="0.1" value="3." list="markers" oninput=onZoomSliderChange(this.value)>
                <label id="zoom-label">Zoom: 1</label>
            </td>
        </tr>
        <!-- Update -->
        <tr>
            <td colspan="2">
                <input type="checkbox" id="progressive-update-checkbox" name="progressive-update-checkbox" onchange=onDoProgressiveUpdatesChange(this.checked)>
                <label for="progressive-update-checkbox">Use progressive updating</label>
            </td>
        </tr>
    </table>
</body>
</html>